# Keycloak IAM Implementation - Ultra Detailed Guide

## Table of Contents

1. [Authentication, RBAC Assignment & JWT Token Generation](#1-authentication-rbac-assignment--jwt-token-generation)
2. [JWT Validation & User Permission](#2-jwt-validation--user-permission)
3. [Request Validation Strategy: Per-Request vs Session-Based](#3-request-validation-strategy-per-request-vs-session-based)
4. [Complete Flow Diagram](#complete-flow-diagram)

---

## How Keycloak Relates to IAM

Keycloak is an open-source Identity Provider (IdP) that implements IAM principles. It provides:

1. **Single Sign-On (SSO)**: Users authenticate once and access multiple applications
2. **Authentication**: Multiple login methods (username/password, social login, MFA, LDAP)
3. **Authorization**: Role-based access control (RBAC) and fine-grained permissions
4. **Token Management**: Issues OAuth 2.0 and OpenID Connect tokens for API access
5. **User Federation**: Connects to existing user directories (Active Directory, LDAP)
6. **Identity Brokering**: Allows login via external identity providers

---

## 1. Authentication, RBAC Assignment & JWT Token Generation

### Phase 1: Initial Authentication Request

When a user attempts to access a protected resource:

#### Step 1.1: Application Redirect

```
User → Application (http://app.example.com/dashboard)
↓
Application detects: No valid session/token
↓
Application redirects to Keycloak Authorization Endpoint:
https://keycloak.example.com/realms/{realm-name}/protocol/openid-connect/auth
  ?client_id=my-application
  &redirect_uri=http://app.example.com/callback
  &response_type=code
  &scope=openid profile email
  &state=random_csrf_token
```

**Parameters Explained:**
- `client_id`: Identifies which application is requesting authentication
- `redirect_uri`: Where to send the user after authentication (must be pre-registered)
- `response_type=code`: OAuth 2.0 Authorization Code flow (most secure)
- `scope`: What information the app wants (openid = identity, profile = user details, email = email address)
- `state`: CSRF protection token generated by application

---

### Phase 2: Keycloak Login Page & User Authentication

#### Step 2.1: Login Form Rendering

Keycloak's authentication SPI (Service Provider Interface) renders the login page:

```
User sees login form at:
https://keycloak.example.com/realms/my-realm/login-actions/authenticate
  ?session_code=xyz
  &execution=abc
  &client_id=my-application
  &tab_id=123
```

#### Step 2.2: User Submits Credentials

```http
POST https://keycloak.example.com/realms/my-realm/login-actions/authenticate

Form Data:
username=john.doe@example.com
password=SecurePassword123!
```

#### Step 2.3: Keycloak Internal Authentication Flow

Keycloak processes this through its **Authentication Flow Engine**:

```
┌─────────────────────────────────────────┐
│   Authentication Flow (Browser Flow)    │
├─────────────────────────────────────────┤
│ 1. Cookie Check (existing session?)    │
│ 2. Identity Provider Redirector        │
│ 3. Username/Password Form              │ ← We're here
│ 4. Conditional OTP (if MFA enabled)    │
│ 5. Conditional WebAuthn                │
└─────────────────────────────────────────┘
```

#### Step 2.4: Password Validation Process

Deep dive into what happens when Keycloak validates the password:

```java
// Internal Keycloak process (simplified)

// 1. Lookup user in database
UserModel user = session.users().getUserByUsername(realm, "john.doe@example.com");

if (user == null) {
    // User doesn't exist - return generic error (security: don't reveal if user exists)
    return "Invalid username or password";
}

// 2. Check if user is enabled
if (!user.isEnabled()) {
    return "Account disabled";
}

// 3. Get password credential
CredentialModel passwordCredential = user.credentialManager()
    .getStoredCredentialsByTypeStream(PasswordCredentialModel.TYPE)
    .findFirst()
    .orElse(null);

// 4. Hash the submitted password with the same algorithm & salt
String submittedPassword = "SecurePassword123!";
byte[] salt = passwordCredential.getSalt();
int iterations = passwordCredential.getHashIterations(); // e.g., 27,500
String algorithm = passwordCredential.getAlgorithm(); // e.g., "pbkdf2-sha256"

// 5. Use PBKDF2 (Password-Based Key Derivation Function 2)
byte[] hashedPassword = PBKDF2.hash(
    submittedPassword.toCharArray(),
    salt,
    iterations,
    algorithm
);

// 6. Constant-time comparison (prevents timing attacks)
boolean passwordValid = MessageDigest.isEqual(
    hashedPassword,
    passwordCredential.getValue() // stored hash
);

if (!passwordValid) {
    // 7. Increment failed login count
    user.incrementFailedLogins();

    // 8. Check brute force protection
    if (user.getFailedLogins() >= bruteForceThreshold) {
        user.setEnabled(false);
        // Send admin notification
    }

    return "Invalid username or password";
}

// 9. Password is valid - reset failed login counter
user.resetFailedLogins();

// 10. Create authenticated session
AuthenticationSessionModel authSession = createAuthSession(user, client);
```

**Database Storage (Keycloak's user_entity and credential tables):**

```sql
-- User table
user_entity:
  id: "abc-123-uuid"
  username: "john.doe@example.com"
  email: "john.doe@example.com"
  enabled: true
  email_verified: true
  realm_id: "my-realm"

-- Credential table
credential:
  id: "credential-uuid"
  user_id: "abc-123-uuid"
  type: "password"
  secret_data: {
    "value": "hashed_password_bytes_base64",
    "salt": "random_salt_bytes_base64",
    "algorithm": "pbkdf2-sha256",
    "hashIterations": 27500
  }
```

---

### Phase 3: Role-Based Access Control (RBAC) Assignment

After successful authentication, Keycloak gathers all roles for the user:

#### Step 3.1: Role Hierarchy in Keycloak

```
Keycloak has THREE role types:

1. Realm Roles (global to the realm)
   └─ admin
   └─ user
   └─ developer

2. Client Roles (specific to an application)
   └─ my-application
      ├─ app-admin
      ├─ app-user
      └─ viewer

3. Composite Roles (bundles of other roles)
   └─ super-admin
      ├─ includes: realm-role:admin
      ├─ includes: client-role:my-application:app-admin
      └─ includes: realm-role:developer
```

#### Step 3.2: User-to-Role Mapping Database

```sql
-- User role mapping table
user_role_mapping:
  user_id: "abc-123-uuid"
  role_id: "role-developer-uuid"

user_role_mapping:
  user_id: "abc-123-uuid"
  role_id: "role-app-user-uuid"

-- Role definitions
keycloak_role:
  id: "role-developer-uuid"
  name: "developer"
  realm_id: "my-realm"
  client_id: null  -- null = realm role

keycloak_role:
  id: "role-app-user-uuid"
  name: "app-user"
  client_id: "my-application-client-uuid"  -- client role
```

#### Step 3.3: Role Collection Process

```java
// Keycloak internally collects ALL roles for the user

Set<RoleModel> roles = new HashSet<>();

// 1. Get direct realm roles
roles.addAll(user.getRealmRoleMappingsStream().collect(Collectors.toSet()));

// 2. Get direct client roles for this specific client
roles.addAll(user.getClientRoleMappingsStream(client).collect(Collectors.toSet()));

// 3. Expand composite roles (recursively)
Set<RoleModel> expandedRoles = RoleUtils.expandCompositeRoles(roles);

// 4. Get group memberships and their roles
user.getGroupsStream().forEach(group -> {
    expandedRoles.addAll(group.getRoleMappingsStream().collect(Collectors.toSet()));
});

// Result for user john.doe@example.com:
// expandedRoles = ["developer", "app-user", "default-roles-my-realm"]
```

#### Step 3.4: Additional User Attributes

Keycloak also collects custom attributes:

```java
// User attributes (stored in user_attribute table)
Map<String, List<String>> attributes = user.getAttributes();

// Example:
{
  "department": ["Engineering"],
  "location": ["New York"],
  "employee_id": ["EMP-12345"],
  "clearance_level": ["confidential"]
}
```

---

### Phase 4: Authorization Code Generation

After successful authentication and role collection:

#### Step 4.1: Create User Session

```java
// 1. Create UserSession (server-side state)
UserSessionModel userSession = session.sessions().createUserSession(
    realm,
    user,
    "john.doe@example.com",
    clientConnection.getRemoteAddr(), // IP: 192.168.1.100
    "openid-connect",
    false, // not remember me
    null,
    null
);

// Stored in Infinispan cache (in-memory) or database:
{
  "id": "session-uuid-xyz",
  "user_id": "abc-123-uuid",
  "started": 1699564800000,
  "lastSessionRefresh": 1699564800000,
  "ipAddress": "192.168.1.100",
  "realm_id": "my-realm"
}

// 2. Create AuthenticatedClientSession (per-client)
AuthenticatedClientSessionModel clientSession = userSession.getAuthenticatedClientSessionByClient(client.getId());
if (clientSession == null) {
    clientSession = userSession.createClientSession(client);
}

// 3. Generate short-lived authorization code (valid ~60 seconds)
String authorizationCode = CodeGenerateUtil.generateCode();
// Example: "ey1234567890abcdef.session-xyz.client-abc"

// 4. Store code mapping
codeStore.put(authorizationCode, new CodeData(
    userSession.getId(),
    client.getId(),
    redirectUri,
    scope,
    nonce,
    state
));
```

#### Step 4.2: Redirect User Back to Application

```http
HTTP/1.1 302 Found
Location: http://app.example.com/callback
  ?code=ey1234567890abcdef.session-xyz.client-abc
  &state=random_csrf_token
```

---

### Phase 5: Token Exchange (Authorization Code → Access Token + ID Token)

#### Step 5.1: Application Backend Exchanges Code for Tokens

```http
POST https://keycloak.example.com/realms/my-realm/protocol/openid-connect/token
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code
&code=ey1234567890abcdef.session-xyz.client-abc
&redirect_uri=http://app.example.com/callback
&client_id=my-application
&client_secret=super-secret-client-secret-xyz
```

#### Step 5.2: Keycloak Validates the Code

```java
// 1. Validate client credentials
ClientModel client = realm.getClientByClientId("my-application");
if (client == null || !client.validateSecret("super-secret-client-secret-xyz")) {
    return error("invalid_client");
}

// 2. Look up code
CodeData codeData = codeStore.get("ey1234567890abcdef.session-xyz.client-abc");
if (codeData == null) {
    return error("invalid_grant", "Code already used or expired");
}

// 3. Validate code hasn't expired (60 second window)
if (codeData.getCreatedAt() + 60_000 < System.currentTimeMillis()) {
    return error("invalid_grant", "Code expired");
}

// 4. Validate redirect_uri matches
if (!codeData.getRedirectUri().equals("http://app.example.com/callback")) {
    return error("invalid_grant", "Redirect URI mismatch");
}

// 5. One-time use: immediately delete code (prevents replay attacks)
codeStore.remove("ey1234567890abcdef.session-xyz.client-abc");

// 6. Retrieve user session
UserSessionModel userSession = session.sessions().getUserSession(
    realm,
    codeData.getUserSessionId()
);
```

---

### Phase 6: JWT Token Generation - THE CORE

This is where the magic happens. Keycloak generates **two tokens**:

1. **Access Token** (for API authorization)
2. **ID Token** (for user identity information)

#### Step 6.1: Access Token Construction

```java
// Create JWT builder
JWTBuilder builder = new JWTBuilder();

// HEADER
Map<String, Object> header = new HashMap<>();
header.put("alg", "RS256");  // RSA Signature with SHA-256
header.put("typ", "JWT");
header.put("kid", "realm-key-id-12345");  // Key ID for rotation

// PAYLOAD (Claims)
Map<String, Object> claims = new HashMap<>();

// Standard JWT claims (RFC 7519)
claims.put("iss", "https://keycloak.example.com/realms/my-realm");  // Issuer
claims.put("sub", "abc-123-uuid");  // Subject (user ID)
claims.put("aud", "my-application");  // Audience (client ID)
claims.put("exp", currentTime + 300);  // Expiration (5 minutes)
claims.put("iat", currentTime);  // Issued at
claims.put("jti", UUID.randomUUID().toString());  // JWT ID (unique identifier)
claims.put("nbf", currentTime);  // Not before

// Session information
claims.put("session_state", "session-uuid-xyz");
claims.put("sid", "session-uuid-xyz");  // Session ID

// OpenID Connect claims
claims.put("azp", "my-application");  // Authorized party
claims.put("scope", "openid profile email");

// User information
claims.put("email_verified", true);
claims.put("name", "John Doe");
claims.put("preferred_username", "john.doe@example.com");
claims.put("given_name", "John");
claims.put("family_name", "Doe");
claims.put("email", "john.doe@example.com");

// CRITICAL: REALM ROLES
claims.put("realm_access", Map.of(
    "roles", List.of("developer", "default-roles-my-realm")
));

// CRITICAL: CLIENT ROLES
claims.put("resource_access", Map.of(
    "my-application", Map.of(
        "roles", List.of("app-user")
    ),
    "account", Map.of(
        "roles", List.of("manage-account", "view-profile")
    )
));

// Custom attributes (from user attributes)
claims.put("department", "Engineering");
claims.put("employee_id", "EMP-12345");

// ACR (Authentication Context Class Reference)
claims.put("acr", "1");  // Level of authentication assurance

// Authentication method
claims.put("auth_time", authTime);
claims.put("typ", "Bearer");
```

#### Step 6.2: Cryptographic Signing

```java
// 1. Get realm's private key (RSA 2048-bit or 4096-bit)
PrivateKey privateKey = realm.getPrivateKey();

// The private key is stored in Keycloak's database:
// component table → 'org.keycloak.keys.KeyProvider'
// Private key is encrypted at rest with AES-256

// 2. Serialize header and claims to JSON
String headerJson = JsonSerialization.writeValueAsString(header);
String claimsJson = JsonSerialization.writeValueAsString(claims);

// 3. Base64URL encode (without padding)
String encodedHeader = Base64Url.encode(headerJson.getBytes(UTF_8));
String encodedClaims = Base64Url.encode(claimsJson.getBytes(UTF_8));

// 4. Create signing input
String signingInput = encodedHeader + "." + encodedClaims;

// 5. Sign with RSA-SHA256
Signature signature = Signature.getInstance("SHA256withRSA");
signature.initSign(privateKey);
signature.update(signingInput.getBytes(UTF_8));
byte[] signatureBytes = signature.sign();

// 6. Base64URL encode signature
String encodedSignature = Base64Url.encode(signatureBytes);

// 7. Construct final JWT
String accessToken = encodedHeader + "." + encodedClaims + "." + encodedSignature;
```

**Example Access Token (decoded for readability):**

```json
// HEADER
{
  "alg": "RS256",
  "typ": "JWT",
  "kid": "realm-key-id-12345"
}

// PAYLOAD
{
  "exp": 1699565100,
  "iat": 1699564800,
  "jti": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "iss": "https://keycloak.example.com/realms/my-realm",
  "aud": "my-application",
  "sub": "abc-123-uuid",
  "typ": "Bearer",
  "azp": "my-application",
  "session_state": "session-uuid-xyz",
  "acr": "1",
  "realm_access": {
    "roles": [
      "developer",
      "default-roles-my-realm"
    ]
  },
  "resource_access": {
    "my-application": {
      "roles": [
        "app-user"
      ]
    }
  },
  "scope": "openid profile email",
  "sid": "session-uuid-xyz",
  "email_verified": true,
  "name": "John Doe",
  "preferred_username": "john.doe@example.com",
  "given_name": "John",
  "family_name": "Doe",
  "email": "john.doe@example.com",
  "department": "Engineering",
  "employee_id": "EMP-12345"
}

// SIGNATURE (binary, base64url-encoded)
```

#### Step 6.3: ID Token Generation

```java
// ID Token is similar but focuses on identity, not authorization
// It contains user profile information

Map<String, Object> idTokenClaims = new HashMap<>();

// Standard claims
idTokenClaims.put("iss", "https://keycloak.example.com/realms/my-realm");
idTokenClaims.put("sub", "abc-123-uuid");
idTokenClaims.put("aud", "my-application");
idTokenClaims.put("exp", currentTime + 300);
idTokenClaims.put("iat", currentTime);
idTokenClaims.put("auth_time", authTime);
idTokenClaims.put("nonce", requestNonce);  // From original auth request

// User profile claims (OpenID Connect standard claims)
idTokenClaims.put("email", "john.doe@example.com");
idTokenClaims.put("email_verified", true);
idTokenClaims.put("name", "John Doe");
idTokenClaims.put("preferred_username", "john.doe@example.com");
idTokenClaims.put("given_name", "John");
idTokenClaims.put("family_name", "Doe");

// ID token is signed the same way as access token
String idToken = signJWT(idTokenClaims);
```

#### Step 6.4: Refresh Token Generation

```java
// Refresh token - long-lived, opaque or JWT
// Used to get new access tokens without re-authentication

Map<String, Object> refreshTokenClaims = new HashMap<>();
refreshTokenClaims.put("iss", "https://keycloak.example.com/realms/my-realm");
refreshTokenClaims.put("sub", "abc-123-uuid");
refreshTokenClaims.put("aud", "my-application");
refreshTokenClaims.put("exp", currentTime + 1800);  // 30 minutes
refreshTokenClaims.put("iat", currentTime);
refreshTokenClaims.put("jti", UUID.randomUUID().toString());
refreshTokenClaims.put("typ", "Refresh");
refreshTokenClaims.put("session_state", "session-uuid-xyz");

String refreshToken = signJWT(refreshTokenClaims);

// Keycloak also stores refresh token in database for revocation capability
```

#### Step 6.5: Token Response

```json
HTTP/1.1 200 OK
Content-Type: application/json

{
  "access_token": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6InJlYWxtLWtleS1pZC0xMjM0NSJ9.eyJleHAiOjE2OTk1NjUxMDAsImlhdCI6MTY5OTU2NDgwMCwianRpIjoiYTFiMmMzZDQtZTVmNi03ODkwLWFiY2QtZWYxMjM0NTY3ODkwIiwiaXNzIjoiaHR0cHM6Ly9rZXljbG9hay5leGFtcGxlLmNvbS9yZWFsbXMvbXktcmVhbG0iLCJhdWQiOiJteS1hcHBsaWNhdGlvbiIsInN1YiI6ImFiYy0xMjMtdXVpZCIsInR5cCI6IkJlYXJlciIsImF6cCI6Im15LWFwcGxpY2F0aW9uIiwic2Vzc2lvbl9zdGF0ZSI6InNlc3Npb24tdXVpZC14eXoiLCJhY3IiOiIxIiwicmVhbG1fYWNjZXNzIjp7InJvbGVzIjpbImRldmVsb3BlciIsImRlZmF1bHQtcm9sZXMtbXktcmVhbG0iXX0sInJlc291cmNlX2FjY2VzcyI6eyJteS1hcHBsaWNhdGlvbiI6eyJyb2xlcyI6WyJhcHAtdXNlciJdfX0sInNjb3BlIjoib3BlbmlkIHByb2ZpbGUgZW1haWwiLCJzaWQiOiJzZXNzaW9uLXV1aWQteHl6IiwiZW1haWxfdmVyaWZpZWQiOnRydWUsIm5hbWUiOiJKb2huIERvZSIsInByZWZlcnJlZF91c2VybmFtZSI6ImpvaG4uZG9lQGV4YW1wbGUuY29tIiwiZ2l2ZW5fbmFtZSI6IkpvaG4iLCJmYW1pbHlfbmFtZSI6IkRvZSIsImVtYWlsIjoiam9obi5kb2VAZXhhbXBsZS5jb20iLCJkZXBhcnRtZW50IjoiRW5naW5lZXJpbmciLCJlbXBsb3llZV9pZCI6IkVNUC0xMjM0NSJ9.signature_here",

  "token_type": "Bearer",
  "expires_in": 300,

  "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2OTk1NjY2MDAsImlhdCI6MTY5OTU2NDgwMCwianRpIjoicmVmcmVzaC10b2tlbi11dWlkIiwiaXNzIjoiaHR0cHM6Ly9rZXljbG9hay5leGFtcGxlLmNvbS9yZWFsbXMvbXktcmVhbG0iLCJhdWQiOiJodHRwczovL2tleWNsb2FrLmV4YW1wbGUuY29tL3JlYWxtcy9teS1yZWFsbSIsInN1YiI6ImFiYy0xMjMtdXVpZCIsInR5cCI6IlJlZnJlc2giLCJhenAiOiJteS1hcHBsaWNhdGlvbiIsInNlc3Npb25fc3RhdGUiOiJzZXNzaW9uLXV1aWQteHl6In0.refresh_signature",

  "refresh_expires_in": 1800,

  "id_token": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6InJlYWxtLWtleS1pZC0xMjM0NSJ9.eyJleHAiOjE2OTk1NjUxMDAsImlhdCI6MTY5OTU2NDgwMCwiYXV0aF90aW1lIjoxNjk5NTY0ODAwLCJqdGkiOiJpZC10b2tlbi11dWlkIiwiaXNzIjoiaHR0cHM6Ly9rZXljbG9hay5leGFtcGxlLmNvbS9yZWFsbXMvbXktcmVhbG0iLCJhdWQiOiJteS1hcHBsaWNhdGlvbiIsInN1YiI6ImFiYy0xMjMtdXVpZCIsInR5cCI6IklEIiwiYXpwIjoibXktYXBwbGljYXRpb24iLCJub25jZSI6InJlcXVlc3Qtbm9uY2UiLCJzZXNzaW9uX3N0YXRlIjoic2Vzc2lvbi11dWlkLXh5eiIsImVtYWlsIjoiam9obi5kb2VAZXhhbXBsZS5jb20iLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwibmFtZSI6IkpvaG4gRG9lIiwicHJlZmVycmVkX3VzZXJuYW1lIjoiam9obi5kb2VAZXhhbXBsZS5jb20iLCJnaXZlbl9uYW1lIjoiSm9obiIsImZhbWlseV9uYW1lIjoiRG9lIn0.id_signature",

  "session_state": "session-uuid-xyz",
  "scope": "openid profile email"
}
```

---

## 2. JWT Validation & User Permission

Now let's explore how Keycloak validates JWT tokens and permits users.

### Scenario: User Makes API Request

```http
GET https://api.example.com/v1/documents/12345
Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6InJlYWxtLWtleS1pZC0xMjM0NSJ9...
```

---

### Validation Method 1: Local JWT Validation (Most Common)

The API/Resource Server validates the JWT **locally** without contacting Keycloak:

#### Step 1: Extract Token from Request

```java
// Extract Bearer token from Authorization header
String authHeader = request.getHeader("Authorization");
if (authHeader == null || !authHeader.startsWith("Bearer ")) {
    return unauthorized("Missing or invalid Authorization header");
}

String token = authHeader.substring(7); // Remove "Bearer " prefix
```

#### Step 2: Parse JWT Structure

```java
// Split JWT into 3 parts
String[] parts = token.split("\\.");
if (parts.length != 3) {
    return unauthorized("Malformed JWT");
}

String encodedHeader = parts[0];
String encodedPayload = parts[1];
String encodedSignature = parts[2];

// Decode header (Base64URL decoding)
byte[] headerBytes = Base64Url.decode(encodedHeader);
String headerJson = new String(headerBytes, UTF_8);
Map<String, Object> header = JsonParser.parse(headerJson);

// Extract algorithm and key ID
String algorithm = (String) header.get("alg");  // "RS256"
String keyId = (String) header.get("kid");      // "realm-key-id-12345"
```

#### Step 3: Fetch Public Key (with Caching)

The resource server needs Keycloak's **public key** to verify the signature:

```java
// Public keys are available at Keycloak's JWKS endpoint
// https://keycloak.example.com/realms/my-realm/protocol/openid-connect/certs

// FIRST TIME: Fetch and cache public keys
if (!publicKeyCache.containsKey(keyId)) {
    // HTTP GET to JWKS endpoint
    String jwksUrl = "https://keycloak.example.com/realms/my-realm/protocol/openid-connect/certs";

    HttpResponse response = httpClient.get(jwksUrl);
    JWKSet jwkSet = JWKSet.parse(response.getBody());

    // Example JWKS response:
    {
      "keys": [
        {
          "kid": "realm-key-id-12345",
          "kty": "RSA",
          "alg": "RS256",
          "use": "sig",
          "n": "0vx7agoebGcQSuuPiLJXZptN9nndrQmbXEps2aiAFbWhM78LhWx4cbbfAAtV...",
          "e": "AQAB",
          "x5c": ["MIIDXTCCAkWgAwIBAgIJAK..."],
          "x5t": "kriOGrwl3o7Zn_M...",
          "x5t#S256": "ZUQqzyBSoaU..."
        }
      ]
    }

    // Extract RSA public key components
    RSAKey rsaKey = (RSAKey) jwkSet.getKeyByKeyId(keyId);
    BigInteger modulus = rsaKey.getModulus();  // 'n' parameter
    BigInteger exponent = rsaKey.getExponent(); // 'e' parameter

    // Construct Java PublicKey object
    RSAPublicKeySpec spec = new RSAPublicKeySpec(modulus, exponent);
    KeyFactory factory = KeyFactory.getInstance("RSA");
    PublicKey publicKey = factory.generatePublic(spec);

    // Cache the public key (for 10 minutes typically)
    publicKeyCache.put(keyId, publicKey, 600_000);
}

PublicKey publicKey = publicKeyCache.get(keyId);
```

#### Step 4: Cryptographic Signature Verification

```java
// 1. Reconstruct signing input (header.payload)
String signingInput = encodedHeader + "." + encodedPayload;

// 2. Decode signature
byte[] signatureBytes = Base64Url.decode(encodedSignature);

// 3. Verify signature with public key
Signature verifier = Signature.getInstance("SHA256withRSA");
verifier.initVerify(publicKey);
verifier.update(signingInput.getBytes(UTF_8));

boolean signatureValid = verifier.verify(signatureBytes);

if (!signatureValid) {
    return unauthorized("Invalid JWT signature - token may be forged");
}

// At this point we know:
// - Token was signed by Keycloak (only Keycloak has the private key)
// - Token has not been tampered with (signature verification passed)
```

#### Step 5: Decode and Validate Claims

```java
// Decode payload
byte[] payloadBytes = Base64Url.decode(encodedPayload);
String payloadJson = new String(payloadBytes, UTF_8);
Map<String, Object> claims = JsonParser.parse(payloadJson);

// 1. Validate expiration
long exp = (Long) claims.get("exp");
long currentTimeSeconds = System.currentTimeMillis() / 1000;

if (currentTimeSeconds > exp) {
    return unauthorized("Token expired");
}

// 2. Validate not-before (nbf)
Long nbf = (Long) claims.get("nbf");
if (nbf != null && currentTimeSeconds < nbf) {
    return unauthorized("Token not yet valid");
}

// 3. Validate issuer
String issuer = (String) claims.get("iss");
String expectedIssuer = "https://keycloak.example.com/realms/my-realm";

if (!expectedIssuer.equals(issuer)) {
    return unauthorized("Invalid issuer");
}

// 4. Validate audience
Object aud = claims.get("aud");
List<String> audiences = aud instanceof List ? (List) aud : List.of((String) aud);

if (!audiences.contains("my-application") && !audiences.contains("api-service")) {
    return unauthorized("Token not intended for this audience");
}

// 5. Validate token type
String tokenType = (String) claims.get("typ");
if (!"Bearer".equals(tokenType)) {
    return unauthorized("Invalid token type");
}

// 6. Optional: Check JTI against revocation list (if using token revocation)
String jti = (String) claims.get("jti");
if (revokedTokens.contains(jti)) {
    return unauthorized("Token has been revoked");
}
```

#### Step 6: Extract User Identity and Roles

```java
// Extract user identity
String userId = (String) claims.get("sub");  // "abc-123-uuid"
String username = (String) claims.get("preferred_username");  // "john.doe@example.com"
String email = (String) claims.get("email");  // "john.doe@example.com"

// Extract realm roles
Map<String, Object> realmAccess = (Map) claims.get("realm_access");
List<String> realmRoles = (List) realmAccess.get("roles");
// ["developer", "default-roles-my-realm"]

// Extract client roles
Map<String, Object> resourceAccess = (Map) claims.get("resource_access");
Map<String, Object> clientAccess = (Map) resourceAccess.get("my-application");
List<String> clientRoles = (List) clientAccess.get("roles");
// ["app-user"]

// Extract custom attributes
String department = (String) claims.get("department");  // "Engineering"
String employeeId = (String) claims.get("employee_id");  // "EMP-12345"

// Create authenticated user object
AuthenticatedUser user = new AuthenticatedUser(
    userId,
    username,
    email,
    realmRoles,
    clientRoles,
    claims  // Full claims for additional attributes
);

// Attach to request context
request.setAttribute("authenticated_user", user);
```

#### Step 7: Authorization Decision (Role-Based Access Control)

```java
// Check if user has required role for this endpoint

// Example: GET /documents/12345 requires "app-user" role

@GET
@Path("/documents/{id}")
@RolesAllowed("app-user")  // JAX-RS annotation
public Response getDocument(@PathParam("id") String documentId) {
    AuthenticatedUser user = request.getAttribute("authenticated_user");

    // Check if user has required role
    if (!user.hasRole("app-user")) {
        return Response.status(403)
            .entity("Forbidden: Missing required role 'app-user'")
            .build();
    }

    // Additional fine-grained authorization
    Document document = documentService.getDocument(documentId);

    if (!document.getOwnerId().equals(user.getUserId())) {
        // User doesn't own this document - check if admin
        if (!user.hasRole("admin")) {
            return Response.status(403)
                .entity("Forbidden: You can only access your own documents")
                .build();
        }
    }

    // Authorization passed - return document
    return Response.ok(document).build();
}
```

#### Step 8: Complete Validation Flow Pseudocode

```java
public class JWTValidator {

    public AuthenticatedUser validateToken(String token) {
        // 1. Parse JWT structure
        JWTParts parts = parseJWT(token);

        // 2. Fetch public key (cached)
        PublicKey publicKey = getPublicKey(parts.header.kid);

        // 3. Verify signature
        if (!verifySignature(parts, publicKey)) {
            throw new UnauthorizedException("Invalid signature");
        }

        // 4. Validate claims
        validateExpiration(parts.claims);
        validateIssuer(parts.claims);
        validateAudience(parts.claims);
        validateNotBefore(parts.claims);

        // 5. Check revocation (optional)
        checkRevocation(parts.claims.jti);

        // 6. Extract user and roles
        return extractUser(parts.claims);
    }
}
```

---

### Validation Method 2: Token Introspection (Server-Side Validation)

For **opaque tokens** or when you need real-time validation, use Keycloak's introspection endpoint:

#### Step 1: Call Introspection Endpoint

```http
POST https://keycloak.example.com/realms/my-realm/protocol/openid-connect/token/introspect
Authorization: Basic base64(client_id:client_secret)
Content-Type: application/x-www-form-urlencoded

token=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6InJlYWxtLWtleS1pZC0xMjM0NSJ9...
&token_type_hint=access_token
```

#### Step 2: Keycloak Response

```json
{
  "active": true,
  "exp": 1699565100,
  "iat": 1699564800,
  "jti": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "iss": "https://keycloak.example.com/realms/my-realm",
  "aud": "my-application",
  "sub": "abc-123-uuid",
  "typ": "Bearer",
  "azp": "my-application",
  "session_state": "session-uuid-xyz",
  "realm_access": {
    "roles": ["developer", "default-roles-my-realm"]
  },
  "resource_access": {
    "my-application": {
      "roles": ["app-user"]
    }
  },
  "scope": "openid profile email",
  "email_verified": true,
  "name": "John Doe",
  "preferred_username": "john.doe@example.com",
  "email": "john.doe@example.com",
  "client_id": "my-application",
  "username": "john.doe@example.com",
  "token_type": "Bearer"
}
```

**Benefits:**
- Real-time validation (checks if token was revoked)
- Works with opaque tokens
- Validates against current session state

**Drawbacks:**
- Network call to Keycloak on every request (latency)
- Increases load on Keycloak
- Single point of failure

---

### Validation Method 3: UserInfo Endpoint

For retrieving current user information:

```http
GET https://keycloak.example.com/realms/my-realm/protocol/openid-connect/userinfo
Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6InJlYWxtLWtleS1pZC0xMjM0NSJ9...
```

```json
{
  "sub": "abc-123-uuid",
  "email_verified": true,
  "name": "John Doe",
  "preferred_username": "john.doe@example.com",
  "given_name": "John",
  "family_name": "Doe",
  "email": "john.doe@example.com"
}
```

---

## 3. Request Validation Strategy: Per-Request vs Session-Based

### Architecture Decision: Where to Validate?

There are **three main patterns**:

---

### Pattern 1: Validate Every Request (Stateless - RECOMMENDED for APIs)

```
Client → API Gateway/Load Balancer → Microservice
         [JWT Validation]            [JWT Validation]
```

**Implementation:**

```java
// API Gateway (Kong, nginx, Envoy) or application middleware

@WebFilter("/api/*")
public class JWTAuthenticationFilter implements Filter {

    private JWTValidator validator;
    private PublicKeyCache keyCache;

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {
        HttpServletRequest req = (HttpServletRequest) request;
        HttpServletResponse res = (HttpServletResponse) response;

        try {
            // Extract token
            String token = extractToken(req);

            if (token == null) {
                res.sendError(401, "Missing authentication token");
                return;
            }

            // VALIDATE ON EVERY REQUEST
            AuthenticatedUser user = validator.validateToken(token);

            // Attach user to request context
            req.setAttribute("user", user);

            // Continue to protected resource
            chain.doFilter(request, response);

        } catch (TokenExpiredException e) {
            res.sendError(401, "Token expired");
        } catch (InvalidTokenException e) {
            res.sendError(401, "Invalid token");
        }
    }
}
```

**When Token is Validated:**
```
Request 1: GET /api/documents
└─ Validate JWT ✓
   └─ Check signature ✓
   └─ Check expiration ✓
   └─ Extract roles ✓
   └─ Authorize ✓

Request 2: POST /api/documents
└─ Validate JWT ✓  (validates AGAIN)
   └─ Check signature ✓
   └─ Check expiration ✓
   └─ Extract roles ✓
   └─ Authorize ✓

Request 3: GET /api/users/me
└─ Validate JWT ✓  (validates AGAIN)
   └─ Check signature ✓
   └─ Check expiration ✓
   └─ Extract roles ✓
   └─ Authorize ✓
```

**Pros:**
- **Stateless**: No server-side session storage
- **Scalable**: Can horizontally scale without session replication
- **Secure**: Tokens can't be revoked server-side, but short expiry (5 min) limits damage
- **Microservices-friendly**: Each service validates independently

**Cons:**
- **CPU overhead**: Signature verification on every request (mitigated by public key caching)
- **Cannot immediately revoke**: User logs out, but tokens valid until expiry

**Performance Optimization:**

```java
// Cache public keys aggressively
public class PublicKeyCache {
    private final LoadingCache<String, PublicKey> cache;

    public PublicKeyCache() {
        this.cache = Caffeine.newBuilder()
            .expireAfterWrite(10, TimeUnit.MINUTES)  // Refresh every 10 min
            .maximumSize(100)
            .build(keyId -> fetchPublicKey(keyId));
    }

    public PublicKey get(String keyId) {
        return cache.get(keyId);
    }
}

// Signature verification is CPU-intensive but fast:
// RSA-2048 signature verification: ~0.1-0.5ms per request
// With modern CPUs: 10,000+ validations/second per core
```

---

### Pattern 2: Session-Based (After Initial Authentication)

```
Client → Application Server → Keycloak
         [Session Cookie]       [First auth only]
```

**Implementation:**

```java
// 1. After OAuth flow completes, create server-side session

@GetMapping("/callback")
public String oauthCallback(@RequestParam("code") String code, HttpSession session) {

    // Exchange code for tokens
    TokenResponse tokens = keycloakClient.exchangeCode(code);

    // Create server-side session
    session.setAttribute("access_token", tokens.getAccessToken());
    session.setAttribute("refresh_token", tokens.getRefreshToken());
    session.setAttribute("user_id", tokens.getClaims().getSub());
    session.setAttribute("roles", tokens.getClaims().getRoles());
    session.setAttribute("token_expires_at", tokens.getExpiresAt());

    // Set session cookie (JSESSIONID)
    // HttpOnly, Secure, SameSite=Strict

    return "redirect:/dashboard";
}

// 2. On subsequent requests, validate session (no JWT validation)

@WebFilter("/*")
public class SessionAuthFilter implements Filter {

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {
        HttpServletRequest req = (HttpServletRequest) request;
        HttpSession session = req.getSession(false);

        if (session == null || session.getAttribute("user_id") == null) {
            // No session - redirect to login
            response.sendRedirect("/login");
            return;
        }

        // Check if access token expired
        long expiresAt = (Long) session.getAttribute("token_expires_at");

        if (System.currentTimeMillis() > expiresAt) {
            // Token expired - refresh it
            String refreshToken = (String) session.getAttribute("refresh_token");

            try {
                TokenResponse newTokens = keycloakClient.refreshToken(refreshToken);

                // Update session with new tokens
                session.setAttribute("access_token", newTokens.getAccessToken());
                session.setAttribute("token_expires_at", newTokens.getExpiresAt());

            } catch (InvalidTokenException e) {
                // Refresh token also expired - re-authenticate
                session.invalidate();
                response.sendRedirect("/login");
                return;
            }
        }

        // Session valid - continue
        chain.doFilter(request, response);
    }
}
```

**Request Flow:**

```
Request 1: GET /dashboard
├─ Check session exists ✓
├─ Check token expiration ✓
└─ Serve response (NO JWT validation)

Request 2: POST /api/documents
├─ Check session exists ✓
├─ Token expired ✗
├─ Use refresh token → Get new access token
├─ Update session
└─ Serve response

Request 3: GET /api/users
├─ Check session exists ✓
├─ Check token expiration ✓
└─ Serve response (NO JWT validation)
```

**Pros:**
- **Faster**: No signature verification on every request
- **Can revoke immediately**: Invalidate server-side session
- **Traditional web app pattern**

**Cons:**
- **Stateful**: Requires session storage (Redis, database, sticky sessions)
- **Scaling complexity**: Session replication across servers
- **Memory overhead**: Store sessions for all users

**Session Storage:**

```java
// Redis-backed session for horizontal scaling

@Bean
public RedisTemplate<String, Object> redisTemplate() {
    // Session data stored in Redis
    // Key: session:abc-123-session-id
    // Value: { user_id, access_token, refresh_token, roles, expires_at }
    // TTL: 30 minutes (session timeout)
}
```

---

### Pattern 3: Hybrid (API Gateway Validation + Service-Level Cache)

```
Client → API Gateway → Microservice A → Microservice B
         [JWT Validation]  [Cache user]    [Cache user]
         [Extract claims]
         [Forward as header]
```

**Implementation:**

```java
// API Gateway (Kong, Envoy, Spring Cloud Gateway)

public class GatewayJWTFilter implements GlobalFilter {

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {

        // 1. Validate JWT once at gateway
        String token = extractToken(exchange);
        AuthenticatedUser user = validator.validateToken(token);

        // 2. Extract user claims and forward as headers to downstream services
        ServerHttpRequest modifiedRequest = exchange.getRequest().mutate()
            .header("X-User-ID", user.getUserId())
            .header("X-User-Email", user.getEmail())
            .header("X-User-Roles", String.join(",", user.getRoles()))
            .header("X-User-Department", user.getDepartment())
            .build();

        // 3. Optionally: Still forward original JWT for service-to-service calls
        // .header("X-Forwarded-Access-Token", token)

        return chain.filter(exchange.mutate().request(modifiedRequest).build());
    }
}

// Downstream Microservice (no JWT validation, trusts gateway)

@RestController
public class DocumentController {

    @GetMapping("/documents/{id}")
    public Document getDocument(
        @PathVariable String id,
        @RequestHeader("X-User-ID") String userId,
        @RequestHeader("X-User-Roles") String rolesHeader
    ) {
        // Trust headers from gateway (must secure network between gateway and services)
        List<String> roles = Arrays.asList(rolesHeader.split(","));

        if (!roles.contains("app-user")) {
            throw new ForbiddenException();
        }

        return documentService.getDocument(id, userId);
    }
}
```

**Request Flow:**

```
Request: GET /api/documents/123

1. Client → API Gateway
   └─ Validate JWT signature ✓
   └─ Validate expiration ✓
   └─ Extract claims ✓
   └─ Add X-User-* headers

2. API Gateway → Document Service
   Headers:
     X-User-ID: abc-123-uuid
     X-User-Roles: app-user,developer
   └─ Document Service trusts headers (no validation)
   └─ Authorize based on roles
   └─ Return document

3. Document Service → User Service (internal call)
   Headers:
     X-User-ID: abc-123-uuid
   └─ User Service trusts headers (no validation)
```

**Pros:**
- **Validate once**: Only at gateway
- **Fast internal calls**: No JWT overhead
- **Clear separation**: Gateway = authentication, services = authorization

**Cons:**
- **Network security critical**: Must ensure only gateway can call services (mTLS, network policies)
- **Header injection risk**: If services exposed directly, attacker could forge X-User-* headers

**Security Measures:**

```yaml
# Kubernetes Network Policy - only allow gateway to call services

apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: document-service-policy
spec:
  podSelector:
    matchLabels:
      app: document-service
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: api-gateway  # Only gateway can call
    ports:
    - protocol: TCP
      port: 8080
```

---

### RECOMMENDATION: Which Pattern to Use?

| **Use Case** | **Pattern** | **Validation Frequency** |
|---|---|---|
| **RESTful APIs** | Pattern 1 (Stateless) | Every request |
| **Traditional web app** | Pattern 2 (Session) | Once per session |
| **Microservices** | Pattern 3 (Hybrid) | Once at gateway |
| **Mobile apps** | Pattern 1 (Stateless) | Every request |
| **Server-to-server** | Pattern 1 + mTLS | Every request |

---

### Token Refresh Flow (Avoiding Re-Authentication)

When access token expires (5 min), use refresh token (30 min+):

```http
POST https://keycloak.example.com/realms/my-realm/protocol/openid-connect/token
Content-Type: application/x-www-form-urlencoded

grant_type=refresh_token
&refresh_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
&client_id=my-application
&client_secret=super-secret-client-secret-xyz
```

**Response:**

```json
{
  "access_token": "new_access_token",
  "token_type": "Bearer",
  "expires_in": 300,
  "refresh_token": "new_refresh_token",
  "refresh_expires_in": 1800
}
```

**Client-Side Implementation (JavaScript):**

```javascript
class TokenManager {
    async fetchWithAuth(url, options = {}) {
        let accessToken = localStorage.getItem('access_token');
        let expiresAt = localStorage.getItem('expires_at');

        // Check if token expired
        if (Date.now() > expiresAt) {
            // Refresh token
            const refreshToken = localStorage.getItem('refresh_token');
            const response = await fetch('https://keycloak.example.com/realms/my-realm/protocol/openid-connect/token', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: new URLSearchParams({
                    grant_type: 'refresh_token',
                    refresh_token: refreshToken,
                    client_id: 'my-application'
                })
            });

            const tokens = await response.json();

            // Update stored tokens
            localStorage.setItem('access_token', tokens.access_token);
            localStorage.setItem('refresh_token', tokens.refresh_token);
            localStorage.setItem('expires_at', Date.now() + tokens.expires_in * 1000);

            accessToken = tokens.access_token;
        }

        // Make API request with (possibly refreshed) token
        return fetch(url, {
            ...options,
            headers: {
                ...options.headers,
                'Authorization': `Bearer ${accessToken}`
            }
        });
    }
}
```

---

## Complete Flow Diagram

```
┌──────────┐                                    ┌──────────────┐
│  Client  │                                    │   Keycloak   │
└──────────┘                                    └──────────────┘
     │                                                  │
     │ 1. Request protected resource                   │
     │─────────────────────────────────────────────────▶
     │                                                  │
     │ 2. Redirect to Keycloak login                   │
     │◀─────────────────────────────────────────────────┤
     │                                                  │
     │ 3. Submit username/password                     │
     │─────────────────────────────────────────────────▶
     │                                                  │
     │            4. Validate credentials               │
     │               ├─ Hash password (PBKDF2)         │
     │               ├─ Check against DB                │
     │               └─ Load roles from DB              │
     │                                                  │
     │ 5. Return authorization code                    │
     │◀─────────────────────────────────────────────────┤
     │                                                  │
     │ 6. Exchange code for tokens                     │
     │─────────────────────────────────────────────────▶
     │                                                  │
     │            7. Generate JWT tokens                │
     │               ├─ Create access token claims      │
     │               ├─ Sign with private key (RS256)   │
     │               ├─ Create ID token                 │
     │               └─ Create refresh token            │
     │                                                  │
     │ 8. Return tokens (access, ID, refresh)          │
     │◀─────────────────────────────────────────────────┤
     │                                                  │
     │                                                  │
┌──────────┐                                    ┌──────────────┐
│  Client  │                                    │  API Server  │
└──────────┘                                    └──────────────┘
     │                                                  │
     │ 9. API request with Bearer token                │
     │─────────────────────────────────────────────────▶
     │                                                  │
     │           10. Validate JWT locally               │
     │               ├─ Fetch public key (cached)       │
     │               ├─ Verify signature                │
     │               ├─ Check expiration                │
     │               ├─ Validate issuer/audience        │
     │               └─ Extract roles                   │
     │                                                  │
     │           11. Authorize based on roles           │
     │               └─ Check user has required role    │
     │                                                  │
     │ 12. Return protected resource                   │
     │◀─────────────────────────────────────────────────┤
     │                                                  │
```

---

## Summary

This document provides an ultra-detailed explanation of how Keycloak implements IAM principles:

1. **Authentication Flow**: From initial login request through password validation, role collection, and authorization code generation
2. **JWT Token Generation**: Complete process of creating, signing, and issuing access tokens with role-based claims
3. **Token Validation**: Three methods for validating JWTs (local validation, introspection, userinfo endpoint)
4. **Authorization**: Role-based access control implementation and permission checking
5. **Architecture Patterns**: Stateless per-request validation, session-based validation, and hybrid gateway approaches

Each section includes actual code implementations, cryptographic details, database schemas, and security considerations used in production Keycloak deployments.
